#pragma once

#include <vector>
#include <memory>
#include "DrawData.h"
#include "Manager.h"
#include "EventManager.h"
#include "FileManagerV2.h"
#include "UIManager.h"
#include "SoulManager.h"

////////////////////////////////////////////////////////////
/// \brief Enum for specifying derived Manager classes.
///////////////////////////////////////////////////////////////
enum class ManagerType : int
{
	INPUT,
	CAMERA,
	EVENT,
	FILE,
	ECONOMY,
	WORLD,
	SOUL,
	REINCARNATION,
	UI
};

class GameManager
{
public:

	~GameManager()
	{
		auto* instance = get();
		delete(instance);
		instance = nullptr;
	};

	////////////////////////////////////////////////////////////
	/// \brief Returns the GameManager singleton.
	///////////////////////////////////////////////////////////////
	static GameManager* get(); // Meyers Singleton

	GameManager(GameManager const&) = delete; // disables copy constructor.
	GameManager& operator=(GameManager const&) = delete; // disables move assignment operator.

	////////////////////////////////////////////////////////////
	/// \brief Is called when the program initializes.
	////////////////////////////////////////////////////////////
	void awake(GameData& _game_data);

	////////////////////////////////////////////////////////////
	/// \brief Called every cycle of the game loop.
	///	\param _timer DeltaTime.
	////////////////////////////////////////////////////////////
	void update(GameData& _game_data);

	////////////////////////////////////////////////////////////
	/// \brief Called every cycle of the game loop, but after update.
	///	\param _timer DeltaTime.
	////////////////////////////////////////////////////////////
	void lateUpdate(GameData& _game_data);

	////////////////////////////////////////////////////////////
	/// \brief Called every cycle of the game loop, but after update.
	///	\param _timer DeltaTime.
	////////////////////////////////////////////////////////////
	void render(DrawData* _draw_data);

	////////////////////////////////////////////////////////////
	/// \brief Called every cycle of the game loop, but after update.
	///	\param _timer DeltaTime.
	////////////////////////////////////////////////////////////
	void render2D(DrawData2D* _draw_data);
	
	////////////////////////////////////////////////////////////
	/// \brief Attempts to add a manager to the vector of managers to updated each tick.
	/// \param _manager The manager to add to the manager vector.
	///	\param _type Type is used to identify what kind of Manager _manager is so that it can be stored within the correct variable.
	////////////////////////////////////////////////////////////
	bool addManager(std::shared_ptr<Manager> _manager, ManagerType _type);

	////////////////////////////////////////////////////////////
	/// \brief Attempts to remove a manager from the vector of managers to be updated each tick.
	/// \param _manager The manager to removed from the manager vector.
	///	\param _type Type is used to identify what kind of Manager _manager is so that it can be removed from the correct variable. 
	////////////////////////////////////////////////////////////
	bool removeManager(std::shared_ptr<Manager> _manager, ManagerType _type);

	////////////////////////////////////////////////////////////
	/// \brief Returns pointer to event manager, use this for triggering events. 
	////////////////////////////////////////////////////////////
	EventManager* getEventManager() { return event_manager; };

	////////////////////////////////////////////////////////////
	/// \brief Returns pointer to File Manager Event, use this for triggering events. 
	////////////////////////////////////////////////////////////
	FileManagerV2* getFileManagerV2() { return file_manager; };

	////////////////////////////////////////////////////////////
	/// \brief Returns pointer to World Manager Event, use this for triggering events. 
	////////////////////////////////////////////////////////////
	WorldManager* getWorldManager() { return world_manager; };

	UIManager* getUIManager() { return ui_manager; };


	////////////////////////////////////////////////////////////
	/// \brief Returns pointer to File Manager Event, use this for triggering events. 
	////////////////////////////////////////////////////////////
	SoulManager* getSoulManager() { return soulManager; };

	////////////////////////////////////////////////////////////
	/// \brief Saves the game to a json file. 
	////////////////////////////////////////////////////////////
	void SaveGame();

	////////////////////////////////////////////////////////////
	/// \brief Loads the game to a json file. 
	////////////////////////////////////////////////////////////
	void LoadGame();

	////////////////////////////////////////////////////////////
	/// \brief Pauses the game
	////////////////////////////////////////////////////////////
	void PauseGame();

	bool isGamePaused() const;

private:
	GameManager() {};

	////////////////////////////////////////////////////////////
	/// \brief Vector of managers to iterate over & update.
	////////////////////////////////////////////////////////////
	std::vector<std::shared_ptr<Manager>> managers;

	////////////////////////////////////////////////////////////
	/// \brief Pointer to EventManager for accessing derived class members.
	////////////////////////////////////////////////////////////
	EventManager* event_manager;


	////////////////////////////////////////////////////////////
	/// \brief Pointer to File Manager Event for accessing derived class members.
	////////////////////////////////////////////////////////////
	FileManagerV2* file_manager;

	////////////////////////////////////////////////////////////
	/// \brief Pointer to World Manager Event for accessing derived class members.
	////////////////////////////////////////////////////////////
	WorldManager* world_manager;

	////////////////////////////////////////////////////////////
	/// \brief Bool to keep track if the game is paused.
	////////////////////////////////////////////////////////////
	bool game_paused = false;


	////////////////////////////////////////////////////////////
	/// \brief Pointer to File Manager Event for accessing derived class members.
	////////////////////////////////////////////////////////////
	SoulManager* soulManager;



	UIManager* ui_manager;
};


inline GameManager* GameManager::get()
{
	static GameManager* instance;

	if (instance == nullptr)
	{
		instance = new GameManager;
	}

	return instance;
}